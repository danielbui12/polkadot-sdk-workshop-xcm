diff --git a/fundamentals/src/xcm_executor.rs b/fundamentals/src/xcm_executor.rs
index d50d85a..f03d79b 100644
--- a/fundamentals/src/xcm_executor.rs
+++ b/fundamentals/src/xcm_executor.rs
@@ -132,14 +132,50 @@ impl<Config: XcmConfig> XcmExecutor<Config> {
 			// - `assets`: The asset(s) to remove from holding.
 			// - `beneficiary`: The new owner for the assets.
 			DepositAsset { assets, beneficiary } => {
-				todo!("{:?} {:?}", assets, beneficiary)
+				let old_holding = self.holding.clone();
+				let result = Config::TransactionalProcessor::process(|| {
+					// Take assets from the holding registrar...
+					let deposited = self.holding.saturating_take(assets);
+					// ... and deposit them to the `beneficiary`.
+					for asset in deposited.into_assets_iter() {
+						Config::AssetTransactor::deposit_asset(
+							&asset,
+							&beneficiary,
+							Some(&self.context),
+						)?;
+					}
+					Ok(())
+				});
+				// If we were unable to execute `deposit_asset` in the `AssetTransactor`, we reset
+				// the XCM Executor holding registrar since no operations took place.
+				if Config::TransactionalProcessor::IS_TRANSACTIONAL && result.is_err() {
+					self.holding = old_holding;
+				}
+				result
 			},
 			// Asset(s) (`assets`) have been destroyed on the `origin` system and equivalent assets
 			// should be created and placed into the Holding Register.
 			//
 			// - `assets`: The asset(s) that are minted into the Holding Register.
 			ReceiveTeleportedAsset(assets) => {
-				todo!("{:?}", assets)
+				Config::TransactionalProcessor::process(|| {
+					let origin = self.origin_ref().ok_or(XcmError::BadOrigin)?;
+					// check whether we trust origin to teleport this asset to us via config trait.
+					for asset in assets.inner() {
+						// We should check that the asset can actually be teleported in (for this to
+						// be in error, there would need to be an accounting violation by one of the
+						// trusted chains, so it's unlikely, but we don't want to punish a possibly
+						// innocent chain/user).
+						Config::AssetTransactor::can_check_in(origin, asset, &self.context)?;
+						Config::AssetTransactor::check_in(origin, asset, &self.context);
+					}
+					Ok(())
+				})
+				.and_then(|_| {
+					// ...and place into holding.
+					self.holding.subsume_assets(assets.into());
+					Ok(())
+				})
 			},
 			// In this workshop, we won't be implementing every instruction, just the ones above...
 			// Our executor will simply panic if you try to execute other instructions.
